import pool from '../config/connectdb.js';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import session from "express-session";
import transporter from '../middleware/mailer.js';
import crypto from 'crypto';

const SECRET_KEY = process.env.JWT_SECRET || "supersecretkey";
let apiLogin = async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    return res.status(400).json({ message: "H√£y nh·∫≠p email v√† password" });
  }

  try {
    // üîπ T√¨m user theo email
    const [results] = await pool.query("SELECT * FROM customers WHERE Email = ?", [email]);

    if (results.length === 0) {
      return res.status(401).json({ message: "Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng" });
    }

    const customer = results[0];
    const storedPassword = customer.PasswordHash;
    console.log(customer)
    let isMatch = false;

    // üîπ Ki·ªÉm tra n·∫øu m·∫≠t kh·∫©u ƒë√£ m√£ h√≥a (bcrypt)
    if (storedPassword.startsWith("$2b$") || storedPassword.startsWith("$2a$")) {
      isMatch = await bcrypt.compare(password, storedPassword);
    } else {
      // üîπ N·∫øu m·∫≠t kh·∫©u ch∆∞a m√£ h√≥a, so s√°nh tr·ª±c ti·∫øp
      isMatch = password === storedPassword;
    }

    if (!isMatch) {
      return res.status(401).json({ message: "Email ho·∫∑c m·∫≠t kh·∫©u sai" });
    }

    // ‚úÖ ƒê·∫£m b·∫£o Role lu√¥n l√† s·ªë nguy√™n
    let role = customer.role !== undefined ? parseInt(customer.role, 10) : 0;

    console.log("üìå Role sau khi l·∫•y t·ª´ DB:", role, "Ki·ªÉu d·ªØ li·ªáu:", typeof role);

    // üõ°Ô∏è T·∫°o token ƒëƒÉng nh·∫≠p
    const token = jwt.sign(
      { id: customer.CustomerID, email: customer.Email, role: role },
      "SECRET_KEY",
      { expiresIn: "1h" }
    );

    // ‚úÖ L∆∞u session
    req.session.user = {
      id: customer.CustomerID,
      fullName: customer.FullName,
      email: customer.Email,
      phone: customer.Phone,
      role: role, // Role ƒë∆∞·ª£c x√°c ƒë·ªãnh r√µ r√†ng
      profilePicture: customer.ProfilePicture || null,
    };

    return res.json({
      message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng",
      user: req.session.user,
      token: token, // G·ª≠i token n·∫øu c·∫ßn d√πng cho x√°c th·ª±c
    });

  } catch (error) {
    console.error("‚ùå L·ªói server:", error);
    return res.status(500).json({ message: "L·ªói server", error });
  }
};
let apiLogOut = async (req,res) =>{
  req.session.destroy();
  res.json({ message: "ƒêƒÉng xu·∫•t th√†nh c√¥ng" });
}
let apiCheck = async (req , res) =>{
if (req.session.user) {
    return res.json({ loggedIn: true, user: req.session.user });
  } else {
    return res.json({ loggedIn: false, message: "Ch∆∞a ƒëƒÉng nh·∫≠p" });
  }
}
const viewProfile = async (req, res) => {
  try {
    const customerId = req.params.id;

    // Ki·ªÉm tra customerId c√≥ h·ª£p l·ªá kh√¥ng (ch·ªâ cho ph√©p s·ªë)
    if (!customerId || isNaN(customerId)) {
      return res.status(400).json({ error: "ID kh√°ch h√†ng kh√¥ng h·ª£p l·ªá" });
    }

    const sql = "SELECT * FROM customers WHERE CustomerID = ?";
    
    // S·ª≠ d·ª•ng pool v·ªõi promise
    const [rows] = await pool.query(sql, [customerId]);

    if (rows.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng" });
    }

    let customer = rows[0];

    // X·ª≠ l√Ω ProfilePicture th√†nh URL ƒë·∫ßy ƒë·ªß
    customer.ProfilePicture = customer.ProfilePicture
      ? `http://localhost:2000/image/${customer.ProfilePicture}`
      : `http://localhost:2000/image/default.jpg`; // ·∫¢nh m·∫∑c ƒë·ªãnh n·∫øu null

    res.json(customer); // Tr·∫£ v·ªÅ th√¥ng tin kh√°ch h√†ng
  } catch (error) {
    console.error("L·ªói truy v·∫•n database:", error);
    res.status(500).json({ error: "L·ªói truy v·∫•n database" });
  }
};
const changeProfile = async (req, res) => {
  try {
    // Ki·ªÉm tra request c√≥ nh·∫≠n params & body kh√¥ng
    console.log("üü¢ API nh·∫≠n request:", req.params, req.body);

    // L·∫•y customerId t·ª´ params
    const customerId = req.params.customerId; 
    if (!customerId) {
      return res.status(400).json({ message: "Thi·∫øu customerId!" });
    }

    // L·∫•y d·ªØ li·ªáu t·ª´ body
    const { FullName, Email, Phone, Gender, Address, District } = req.body;
    if (!FullName || !Email || !Phone) {
      return res.status(400).json({ message: "Thi·∫øu d·ªØ li·ªáu c·∫≠p nh·∫≠t!" });
    }

    // Ki·ªÉm tra kh√°ch h√†ng c√≥ t·ªìn t·∫°i kh√¥ng
    const [customer] = await pool.query("SELECT * FROM customers WHERE customerId = ?", [customerId]);
    console.log("üîç Ki·ªÉm tra kh√°ch h√†ng:", customer);

    if (!customer || customer.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng!" });
    }

    // C·∫≠p nh·∫≠t th√¥ng tin
    const [result] = await pool.query(
      "UPDATE customers SET FullName = ?, Email = ?, Phone = ?, Gender = ?, Address = ?, District = ? WHERE customerId = ?",
      [FullName, Email, Phone, Gender, Address, District, customerId]
    );

    if (result.affectedRows === 0) {
      return res.status(500).json({ message: "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t kh√°ch h√†ng!" });
    }

    console.log("‚úÖ C·∫≠p nh·∫≠t th√†nh c√¥ng!");
    res.json({ message: "C·∫≠p nh·∫≠t th√¥ng tin th√†nh c√¥ng!" });
  } catch (error) {
    console.error("üö® L·ªói c·∫≠p nh·∫≠t kh√°ch h√†ng:", error);
    res.status(500).json({ message: "L·ªói m√°y ch·ªß!" });
  }
};
const changeAvatar = async (req, res) => {
  try {
    const { customerId } = req.params;

    console.log("üì© File nh·∫≠n ƒë∆∞·ª£c:", req.file); // Log th√¥ng tin file
    console.log("üìå Customer ID:", customerId); // Log ID kh√°ch h√†ng

    if (!req.file) {
      return res.status(400).json({ message: "Vui l√≤ng ch·ªçn t·ªáp ·∫£nh!" });
    }

    // Ki·ªÉm tra kh√°ch h√†ng c√≥ t·ªìn t·∫°i kh√¥ng
    const [customer] = await pool.query("SELECT * FROM customers WHERE customerId = ?", [customerId]);
    if (customer.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng!" });
    }

    // C·∫≠p nh·∫≠t ƒë∆∞·ªùng d·∫´n ·∫£nh trong database
    
     const filePath = `${req.file.filename}`;
    await pool.query("UPDATE customers SET ProfilePicture = ? WHERE customerId = ?", [filePath, customerId]);

    res.json({ message: "C·∫≠p nh·∫≠t ·∫£nh ƒë·∫°i di·ªán th√†nh c√¥ng!", fileName: req.file.filename });
  } catch (error) {
    console.error("‚ùå L·ªói upload ·∫£nh:", error);
    res.status(500).json({ message: "L·ªói m√°y ch·ªß!", error: error.message });
  }
};
// const regisTer = async (req, res) => {
//   try {
//     const { fullName, email, phone, password, gender } = req.body;

//     if (!fullName || !email || !phone || !password || !gender) {
//       return res.status(400).json({ message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin" });
//     }

//     let [existingUsers] = await pool.execute("SELECT * FROM customers WHERE Email = ?", [email]);

//     if (existingUsers.length > 0) {
//       return res.status(400).json({ message: "Email ƒë√£ t·ªìn t·∫°i" });
//     }

//     const hashedPassword = await bcrypt.hash(password, 10);
//     // ƒê∆∞·ªùng d·∫´n ·∫£nh m·∫∑c ƒë·ªãnh trong th∆∞ m·ª•c public/images
//     const defaultAvatar = `db1.png`;

//     const sql = `INSERT INTO customers (FullName, Email, Phone, PasswordHash, Gender, ProfilePicture) 
//                  VALUES (?, ?, ?, ?, ?, ?)`;

//     let [result] = await pool.execute(sql, [fullName, email, phone, hashedPassword, gender, defaultAvatar]);

//     res.status(201).json({ message: "ƒêƒÉng k√Ω th√†nh c√¥ng", userId: result.insertId });

//   } catch (error) {
//     console.error("L·ªói ƒëƒÉng k√Ω:", error);
//     res.status(500).json({ message: "L·ªói server" });
//   }
// };
const regisTer = async (req, res) => {
  try {
    const { fullName, email, phone, password, gender } = req.body;

    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!fullName || !email || !phone || !password || !gender) {
      return res.status(400).json({ message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin" });
    }

    // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
    let [existingUsers] = await pool.execute(
      "SELECT * FROM customers WHERE Email = ?", 
      [email]
    );
    if (existingUsers.length > 0) {
      return res.status(400).json({ message: "Email ƒë√£ t·ªìn t·∫°i" });
    }

    // M√£ ho√° m·∫≠t kh·∫©u
    const hashedPassword = await bcrypt.hash(password, 10);

    // ·∫¢nh m·∫∑c ƒë·ªãnh
    const defaultAvatar = "ph.jpg";

    // INSERT user m·ªõi, g√°n role = 0
    const sql = `
      INSERT INTO customers (
        FullName, 
        Email, 
        Phone, 
        PasswordHash, 
        Gender, 
        ProfilePicture, 
        role
      ) 
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `;

    let [result] = await pool.execute(sql, [
      fullName, 
      email, 
      phone, 
      hashedPassword, 
      gender, 
      defaultAvatar, 
      0
    ]);

    return res.status(201).json({ 
      message: "ƒêƒÉng k√Ω th√†nh c√¥ng", 
      userId: result.insertId 
    });
  } catch (error) {
    console.error("L·ªói ƒëƒÉng k√Ω:", error);
    return res.status(500).json({ message: "L·ªói server" });
  }
};
const apiOTP = async (req, res) => {
  const { email } = req.body;

  try {
    // Ki·ªÉm tra email c√≥ t·ªìn t·∫°i kh√¥ng
    const [rows] = await pool.query("SELECT * FROM customers WHERE Email = ?", [email]);

    if (rows.length === 0) {
      return res.status(400).json({ message: "Email kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng" });
    }

    // T·∫°o OTP 6 ch·ªØ s·ªë
    const otp = crypto.randomInt(100000, 999999).toString();

    // T·∫°o JWT ch·ª©a OTP v√† email, h·∫øt h·∫°n sau 5 ph√∫t
    const otpToken = jwt.sign({ email, otp }, SECRET_KEY, { expiresIn: "10m" });


    // G·ª≠i email ch·ª©a OTP Token
    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: email,
      subject: "M√£ x√°c th·ª±c OTP - ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u",
      text: `M√£ OTP c·ªßa b·∫°n l√†: ${otp}. OTP n√†y s·∫Ω h·∫øt h·∫°n sau 5 ph√∫t. 
      ƒê·ªÉ x√°c th·ª±c, h√£y g·ª≠i OTP k√®m theo token n√†y: ${otpToken}`,
    });

    res.json({ message: "OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n", otpToken });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng" });
  }
}
const resetPassword = async (req, res) => {
  const { email, otp, otpToken } = req.body;

  try {
    // Gi·∫£i m√£ JWT ƒë·ªÉ l·∫•y OTP
    let decoded;
    try {
      decoded = jwt.verify(otpToken, SECRET_KEY);
    } catch (err) {
      return res.status(400).json({ message: "OTP ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá" });
    }

    // Ki·ªÉm tra email c√≥ kh·ªõp v·ªõi email trong token kh√¥ng
    if (decoded.email !== email) {
      return res.status(400).json({ message: "Email kh√¥ng h·ª£p l·ªá" });
    }

    // Ki·ªÉm tra OTP c√≥ kh·ªõp kh√¥ng
    if (decoded.otp !== otp) {
      return res.status(400).json({ message: "OTP kh√¥ng h·ª£p l·ªá" });
    }

    // T·∫°o m·∫≠t kh·∫©u m·ªõi ng·∫´u nhi√™n
    const newPassword = crypto.randomBytes(6).toString("hex");
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u m·ªõi trong database
    await pool.query("UPDATE customers SET PasswordHash = ? WHERE Email = ?", [hashedPassword, email]);

    // G·ª≠i m·∫≠t kh·∫©u m·ªõi qua email
    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: email,
      subject: "M·∫≠t kh·∫©u m·ªõi c·ªßa b·∫°n",
      text: `M·∫≠t kh·∫©u m·ªõi c·ªßa b·∫°n l√†: ${newPassword}. Vui l√≤ng ƒëƒÉng nh·∫≠p v√† ƒë·ªïi m·∫≠t kh·∫©u ngay!`,
    });

    res.json({ message: "M·∫≠t kh·∫©u m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng" });
  }
};

export default { 
  apiLogin,regisTer,apiLogOut,
  apiCheck,apiOTP,resetPassword,
  viewProfile,changeProfile,changeAvatar
 };

